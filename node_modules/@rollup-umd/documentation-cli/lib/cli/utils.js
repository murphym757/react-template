"use strict";

var fs = require('fs');

var _require = require('child_process'),
    spawnDefault = _require.spawn,
    execDefault = _require.exec;

var exec = function exec(command, cb) {
  execDefault(command, {
    maxBuffer: 1024 * 1024
  }, cb);
};

var spawn = function spawn(command, cb) {
  var split = command.split(' ');
  var program = split[0];
  var args = split.slice(1);
  var child = spawnDefault(program, args || []);
  var outputList = [];
  child.stdout.setEncoding('utf8');
  child.stderr.setEncoding('utf8');
  child.stdout.on('data', function (data) {
    return outputList.push(data) && console.log(data.replace(/\n$/, ''));
  }); // eslint-disable-line no-console

  child.stderr.on('data', function (data) {
    return outputList.push(data) && console.log(data.replace(/\n$/, ''));
  }); // eslint-disable-line no-console

  child.on('close', function (code) {
    return code === 1 ? cb(new Error("child process exited with code ".concat(code), [outputList.join('')])) : cb(null, [outputList.join('')]);
  });
};

var sedReplace = function sedReplace(input, before, after, output) {
  var cb = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : function () {};
  var file = fs.readFileSync(input, 'utf8');
  var re = new RegExp(escapeRegExp(before), 'gm');
  var newFile = file.replace(re, after);
  fs.writeFileSync(output, newFile, 'utf8');
  cb();
};

function escapeRegExp(text) {
  return text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
}

module.exports = {
  exec: exec,
  spawn: spawn,
  sedReplace: sedReplace
};