"use strict";

/* eslint-disable */
var path = require('path');

var fs = require('fs');

var async = require('async');

var _require = require('../utils'),
    spawn = _require.spawn,
    exec = _require.exec,
    sedReplace = _require.sedReplace;

var emptyLink = function emptyLink(pkg, lang, isPrivate) {
  return isPrivate ? "*empty* ([edit now](".concat(pkg.bugs.url.split('/issues')[0], "/edit/dev/translate/").concat(lang, ".json))") : "*empty*";
};

require('shelljs/global');

exports.command = 'intl';
exports.desc = 'Create internationalization documentation.';

exports.builder = function (yargs) {
  return yargs.option('path', {
    alias: 'p',
    describe: 'path',
    default: process.cwd()
  });
};

exports.handler = function (argv) {
  switch (argv.path[0]) {
    case '/':
      break;

    default:
      argv.path = argv.path[1] === '/' ? path.join(process.cwd(), argv.path.slice(2)) : path.join(process.cwd(), argv.path);
      break;
  }

  var thisPkg = require(path.join(__dirname, '../../../package.json'));

  var pkg = require(path.join(argv.path, 'package.json'));

  if (!pkg.dependencies['react-intl'] && !pkg.devDependencies['react-intl']) {
    console.log('[Error] - You must use the react-intl package to use this command!');
    return;
  }

  var preparePath = path.join(argv.path, 'styleguide/prepare.sh');
  var configPath = path.join(argv.path, 'styleguide/styleguide.ext.json');

  var config = require(configPath);

  if (!pkg.translation) {
    throw new Error('You must run intl install first. (eg: intl install en fr de --default=en');
  }

  var readmeList = [];
  var start = '**Import translation**\n\n';
  start += "```js static\nimport englishMessages from '$PACKAGE_NAME/translate/en.json';\n```";
  start += "\n\n> Locales can be configured within your `package.json` under `translation` or using `npx @rollup-umd/intl install` command.";
  start += '\n';
  async.auto({
    runExtract: function runExtract(cb) {
      return spawn("npx @rollup-umd/intl extract", cb);
    },
    isPrivate: function isPrivate(cb) {
      return spawn("npx rollup-umd-scripts publish status | tail -1", cb);
    },
    setupCi: function setupCi(cb) {
      if (!fs.existsSync(configPath)) {
        cb();
        return;
      }

      exec("grep -q \"npx @rollup-umd/documentation-cli intl\" ".concat(preparePath, " || echo true"), function (err, res) {
        if (res && res.indexOf('true') !== -1) {
          exec("echo npx @rollup-umd/documentation-cli intl >> ".concat(preparePath), cb);
          return;
        }

        cb();
      });
    },
    makeDoc: ['runExtract', 'isPrivate', 'setupCi', function (res, cb) {
      var isPrivate = !((res.isPrivate[0].split('tail')[1] || res.isPrivate).indexOf('private') === -1); // ugly but support both internal cli and external cli

      pkg.translation.locales.forEach(function (locale) {
        var translationPath = path.join(argv.path, 'translation', "".concat(locale, ".json"));

        if (fs.existsSync(translationPath)) {
          var messages = require(translationPath);

          var readme = '\n';
          readme += pkg.translation.locale === locale ? "## ".concat(locale, " (default)") : "## ".concat(locale);
          readme += '\n\n';
          readme += "| id | defaultMessage |";
          readme += '\n';
          readme += "|----|----------------|";
          readme += '\n';
          Object.keys(messages).forEach(function (key) {
            readme += "| `".concat(key, "` | ").concat(messages[key] ? "`".concat(messages[key], "`") : emptyLink(pkg, locale, isPrivate), " |");
            readme += '\n';
          });
          readme += '\n';
          readmeList.push({
            locale: locale,
            readme: readme
          });
        }
      });
      var final = start;
      readmeList.forEach(function (readme) {
        final += readme.readme;
      });
      final += '*This file is automatically generated. Do not edit.*';
      final += '\n';
      fs.writeFileSync(path.join(argv.path, 'docs/translation.md'), final, 'utf-8');
      var intlDocSection = config.sections.filter(function (section) {
        return section.name === 'Translation';
      })[0];

      if (!intlDocSection) {
        var faqInd = 0;
        config.sections.filter(function (section, i) {
          if (section.name === 'FAQ') {
            faqInd = i;
          }
        });
        config.sections = config.sections.slice(0, faqInd).concat([{
          name: 'Translation',
          content: 'docs/translation.md'
        }]).concat(config.sections.slice(faqInd));
        fs.writeFileSync(configPath, JSON.stringify(config, null, 2), {
          encoding: 'utf8'
        });
      }

      console.log("".concat(path.join(argv.path, 'docs/translation.md'), " has been updated"));
    }]
  }, function (err, res) {
    if (err) {
      console.error("[ERROR] ".concat(err.message));
      process.exit(1);
    }

    console.log('[Success] Internationalization documentation generated.');
  });
};