"use strict";

/* eslint-disable no-undef, no-param-reassign, global-require, no-unused-vars, no-console, no-underscore-dangle, prefer-destructuring */
var async = require('async');

var path = require('path');

var glob = require('glob');

var _require = require('../utils'),
    sedReplace = _require.sedReplace;

function escapeRegExp(text) {
  return text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
}

exports.command = 'variable <variable> [variables..]';
exports.desc = 'Replace variable(s) in {{docs,src/components}/**/*.md,*.md} (eg: `SOMETHING=value`)';

exports.builder = function (yargs) {
  return yargs.option('path', {
    alias: 'p',
    describe: 'path',
    default: process.cwd()
  }).option('pattern', {
    alias: 'r',
    describe: 'Replace pattern',
    default: '{{docs,src/components}/**/*.md,**/*.md}'
  }).option('only-doc', {
    alias: 'd',
    describe: 'Replace variable(s) only in {docs,src/{**,components}}/*.md',
    default: false
  });
};

exports.handler = function (argv) {
  switch (argv.path[0]) {
    case '/':
      break;

    default:
      argv.path = argv.path[1] === '/' ? path.join(process.cwd(), argv.path.slice(2)) : path.join(process.cwd(), argv.path);
      break;
  }

  var pattern = path.join(argv.path, argv['only-doc'] ? '{docs,src/{**,components}}/*.md' : argv.pattern);
  var options = {
    nonull: false
  };
  glob(pattern, options, function (er, files) {
    files.forEach(function (file) {
      async.map([].concat(argv.variable).concat(argv.variables), function (variable, cb) {
        var split = variable.split('=');
        var before = split[0];
        before = before[0] === '$' ? before : "$".concat(before);
        var after = split[1];
        var output = file;
        sedReplace(output, before, after, output, cb);
      }, function (err, results) {
        if (err) {
          console.error("[ERROR] ".concat(err.message));
          process.exit(1);
        }
      });
    });
  });
};